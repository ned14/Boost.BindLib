<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QuickCppLib: quickcpplib::_xxx::erasure_cast Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">QuickCppLib
   &#160;<span id="projectnumber">0.10</span>
   </div>
   <div id="projectbrief">Eliminate all the tedious hassle when making state-of-the-art C++ 14 - 23 libraries!</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacequickcpplib_1_1__xxx_1_1erasure__cast.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">quickcpplib::_xxx::erasure_cast Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacequickcpplib_1_1__xxx_1_1erasure__cast_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1erasure__cast_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9aa14ebac2550d66d905e5499094568e"><td class="memTemplParams" colspan="2">template&lt;class To , class From , typename std::enable_if&lt;(detail::is_erasure_castable&lt; To, From &gt;::value &amp;&amp;(sizeof(To)==sizeof(From))), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:a9aa14ebac2550d66d905e5499094568e"><td class="memTemplItemLeft" align="right" valign="top">constexpr To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1erasure__cast.html#a9aa14ebac2550d66d905e5499094568e">erasure_cast</a> (const From &amp;from, detail::bit_cast_equivalence_overload={}) noexcept</td></tr>
<tr class="memdesc:a9aa14ebac2550d66d905e5499094568e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasure cast implementation chosen if types are move relocating or trivally copyable, have identical size, and are bit castable. Constexpr. Forwards to <code>bit_cast()</code> directly.  <a href="namespacequickcpplib_1_1__xxx_1_1erasure__cast.html#a9aa14ebac2550d66d905e5499094568e">More...</a><br /></td></tr>
<tr class="separator:a9aa14ebac2550d66d905e5499094568e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff1d6c353aea5799528e3be643d2b14"><td class="memTemplParams" colspan="2">template&lt;class To , class From , typename std::enable_if&lt;(detail::is_erasure_castable&lt; To, From &gt;::value &amp;&amp;detail::is_static_castable&lt; To, From &gt;::value &amp;&amp;(sizeof(To)&lt; sizeof(From))), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:abff1d6c353aea5799528e3be643d2b14"><td class="memTemplItemLeft" align="right" valign="top">constexpr To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1erasure__cast.html#abff1d6c353aea5799528e3be643d2b14">erasure_cast</a> (const From &amp;from, detail::static_cast_dest_smaller_overload={}) noexcept</td></tr>
<tr class="memdesc:abff1d6c353aea5799528e3be643d2b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasure cast implementation chosen if types are move relocating or trivally copyable, are statically castable, and destination type is smaller than source type. Constexpr.  <a href="namespacequickcpplib_1_1__xxx_1_1erasure__cast.html#abff1d6c353aea5799528e3be643d2b14">More...</a><br /></td></tr>
<tr class="separator:abff1d6c353aea5799528e3be643d2b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ced80a81d8e7d82264735382b3675f5"><td class="memTemplParams" colspan="2">template&lt;class To , class From , typename std::enable_if&lt;(detail::is_erasure_castable&lt; To, From &gt;::value &amp;&amp;detail::is_static_castable&lt; To, From &gt;::value &amp;&amp;(sizeof(To) &gt; sizeof(From))), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:a9ced80a81d8e7d82264735382b3675f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1erasure__cast.html#a9ced80a81d8e7d82264735382b3675f5">erasure_cast</a> (const From &amp;from, detail::static_cast_dest_larger_overload={}) noexcept</td></tr>
<tr class="memdesc:a9ced80a81d8e7d82264735382b3675f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasure cast implementation chosen if types are move relocating or trivally copyable, are statically castable, and destination type is larger than source type. Constexpr.  <a href="namespacequickcpplib_1_1__xxx_1_1erasure__cast.html#a9ced80a81d8e7d82264735382b3675f5">More...</a><br /></td></tr>
<tr class="separator:a9ced80a81d8e7d82264735382b3675f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723a3213490dec28ff3da60f7a5dec3d"><td class="memTemplParams" colspan="2">template&lt;class To , class From , typename std::enable_if&lt;(detail::is_erasure_castable&lt; To, From &gt;::value &amp;&amp;!detail::is_static_castable&lt; To, From &gt;::value &amp;&amp;(sizeof(To)&lt; sizeof(From))), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:a723a3213490dec28ff3da60f7a5dec3d"><td class="memTemplItemLeft" align="right" valign="top">constexpr To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1erasure__cast.html#a723a3213490dec28ff3da60f7a5dec3d">erasure_cast</a> (const From &amp;from, detail::union_cast_dest_smaller_overload={}) noexcept</td></tr>
<tr class="memdesc:a723a3213490dec28ff3da60f7a5dec3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasure cast implementation chosen if types are move relocating or trivally copyable, are union castable, and destination type is smaller than source type. May be constexpr if underlying bit cast is constexpr.  <a href="namespacequickcpplib_1_1__xxx_1_1erasure__cast.html#a723a3213490dec28ff3da60f7a5dec3d">More...</a><br /></td></tr>
<tr class="separator:a723a3213490dec28ff3da60f7a5dec3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adebb4ce3b12ae221cac5295dbfd5288e"><td class="memTemplParams" colspan="2">template&lt;class To , class From , typename std::enable_if&lt;(detail::is_erasure_castable&lt; To, From &gt;::value &amp;&amp;!detail::is_static_castable&lt; To, From &gt;::value &amp;&amp;(sizeof(To) &gt; sizeof(From))), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:adebb4ce3b12ae221cac5295dbfd5288e"><td class="memTemplItemLeft" align="right" valign="top">constexpr To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1erasure__cast.html#adebb4ce3b12ae221cac5295dbfd5288e">erasure_cast</a> (const From &amp;from, detail::union_cast_dest_larger_overload={}) noexcept</td></tr>
<tr class="memdesc:adebb4ce3b12ae221cac5295dbfd5288e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erasure cast implementation chosen if types are move relocating or trivally copyable, are union castable, and destination type is larger than source type. May be constexpr if underlying bit cast is constexpr.  <a href="namespacequickcpplib_1_1__xxx_1_1erasure__cast.html#adebb4ce3b12ae221cac5295dbfd5288e">More...</a><br /></td></tr>
<tr class="separator:adebb4ce3b12ae221cac5295dbfd5288e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9aa14ebac2550d66d905e5499094568e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa14ebac2550d66d905e5499094568e">&#9670;&nbsp;</a></span>erasure_cast() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class To , class From , typename std::enable_if&lt;(detail::is_erasure_castable&lt; To, From &gt;::value &amp;&amp;(sizeof(To)==sizeof(From))), bool &gt;::type  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr To quickcpplib::_xxx::erasure_cast::erasure_cast </td>
          <td>(</td>
          <td class="paramtype">const From &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::bit_cast_equivalence_overload&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erasure cast implementation chosen if types are move relocating or trivally copyable, have identical size, and are bit castable. Constexpr. Forwards to <code>bit_cast()</code> directly. </p>
<div class="fragment"><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;{}) noexcept { <span class="keywordflow">return</span> bit_cast&lt;To&gt;(from); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="abff1d6c353aea5799528e3be643d2b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff1d6c353aea5799528e3be643d2b14">&#9670;&nbsp;</a></span>erasure_cast() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class To , class From , typename std::enable_if&lt;(detail::is_erasure_castable&lt; To, From &gt;::value &amp;&amp;detail::is_static_castable&lt; To, From &gt;::value &amp;&amp;(sizeof(To)&lt; sizeof(From))), bool &gt;::type  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr To quickcpplib::_xxx::erasure_cast::erasure_cast </td>
          <td>(</td>
          <td class="paramtype">const From &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::static_cast_dest_smaller_overload&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erasure cast implementation chosen if types are move relocating or trivally copyable, are statically castable, and destination type is smaller than source type. Constexpr. </p>
<div class="fragment"><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;{}) noexcept { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>To<span class="keyword">&gt;</span>(bit_cast&lt;detail::erasure_integer_type&lt;From, To&gt;&gt;(from)); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9ced80a81d8e7d82264735382b3675f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ced80a81d8e7d82264735382b3675f5">&#9670;&nbsp;</a></span>erasure_cast() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class To , class From , typename std::enable_if&lt;(detail::is_erasure_castable&lt; To, From &gt;::value &amp;&amp;detail::is_static_castable&lt; To, From &gt;::value &amp;&amp;(sizeof(To) &gt; sizeof(From))), bool &gt;::type  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr To quickcpplib::_xxx::erasure_cast::erasure_cast </td>
          <td>(</td>
          <td class="paramtype">const From &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::static_cast_dest_larger_overload&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erasure cast implementation chosen if types are move relocating or trivally copyable, are statically castable, and destination type is larger than source type. Constexpr. </p>
<div class="fragment"><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;{}) noexcept { <span class="keywordflow">return</span> bit_cast&lt;To&gt;(<span class="keyword">static_cast&lt;</span>detail::erasure_integer_type&lt;To, From&gt;<span class="keyword">&gt;</span>(from)); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a723a3213490dec28ff3da60f7a5dec3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723a3213490dec28ff3da60f7a5dec3d">&#9670;&nbsp;</a></span>erasure_cast() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class To , class From , typename std::enable_if&lt;(detail::is_erasure_castable&lt; To, From &gt;::value &amp;&amp;!detail::is_static_castable&lt; To, From &gt;::value &amp;&amp;(sizeof(To)&lt; sizeof(From))), bool &gt;::type  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr To quickcpplib::_xxx::erasure_cast::erasure_cast </td>
          <td>(</td>
          <td class="paramtype">const From &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::union_cast_dest_smaller_overload&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erasure cast implementation chosen if types are move relocating or trivally copyable, are union castable, and destination type is smaller than source type. May be constexpr if underlying bit cast is constexpr. </p>
<div class="fragment"><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;{}) noexcept { <span class="keywordflow">return</span> <a class="code" href="namespacequickcpplib_1_1__xxx_1_1bit__cast.html#ab36ed06eda7ed96f27c6db65bfcdec34">bit_cast</a>&lt;detail::padded_erasure_object&lt;To, <span class="keyword">sizeof</span>(From) - <span class="keyword">sizeof</span>(To)&gt;&gt;(from).value; }</div>
<div class="ttc" id="anamespacequickcpplib_1_1__xxx_1_1bit__cast_html_ab36ed06eda7ed96f27c6db65bfcdec34"><div class="ttname"><a href="namespacequickcpplib_1_1__xxx_1_1bit__cast.html#ab36ed06eda7ed96f27c6db65bfcdec34">quickcpplib::_xxx::bit_cast::bit_cast</a></div><div class="ttdeci">constexpr To bit_cast(const From &amp;from, detail::static_cast_overload={}) noexcept</div><div class="ttdoc">Bit cast emulation chosen if types are move relocating or trivally copyable, have identical size,...</div><div class="ttdef"><b>Definition:</b> bit_cast.hpp:121</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="adebb4ce3b12ae221cac5295dbfd5288e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adebb4ce3b12ae221cac5295dbfd5288e">&#9670;&nbsp;</a></span>erasure_cast() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class To , class From , typename std::enable_if&lt;(detail::is_erasure_castable&lt; To, From &gt;::value &amp;&amp;!detail::is_static_castable&lt; To, From &gt;::value &amp;&amp;(sizeof(To) &gt; sizeof(From))), bool &gt;::type  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr To quickcpplib::_xxx::erasure_cast::erasure_cast </td>
          <td>(</td>
          <td class="paramtype">const From &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::union_cast_dest_larger_overload&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erasure cast implementation chosen if types are move relocating or trivally copyable, are union castable, and destination type is larger than source type. May be constexpr if underlying bit cast is constexpr. </p>
<div class="fragment"><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;{}) noexcept { <span class="keywordflow">return</span> bit_cast&lt;To&gt;(detail::padded_erasure_object&lt;From, <span class="keyword">sizeof</span>(To) - <span class="keyword">sizeof</span>(From)&gt;{from}); }</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacequickcpplib.html">quickcpplib</a></li><li class="navelem"><a class="el" href="namespacequickcpplib_1_1__xxx.html">_xxx</a></li><li class="navelem"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1erasure__cast.html">erasure_cast</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
