<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QuickCppLib: include/quickcpplib/signal_guard.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">QuickCppLib<span id="projectnumber">&#160;0.10</span>
   </div>
   <div id="projectbrief">Eliminate all the tedious hassle when making state-of-the-art C++ 14 - 23 libraries!</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('signal__guard_8hpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">signal_guard.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="config_8hpp.html">config.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cpp__feature_8h.html">cpp_feature.h</a>&quot;</code><br />
<code>#include &lt;setjmp.h&gt;</code><br />
<code>#include &lt;signal.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &quot;<a class="el" href="bitfield_8hpp.html">bitfield.hpp</a>&quot;</code><br />
<code>#include &lt;atomic&gt;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;exception&gt;</code><br />
<code>#include &lt;new&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionraised__signal__info__value.html">raised_signal_info_value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">User defined value.  <a href="unionraised__signal__info__value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structraised__signal__info.html">raised_signal_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A platform independent subset of <code>siginfo_t</code>.  <a href="structraised__signal__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquickcpplib_1_1__xxx_1_1signal__guard_1_1signal__guard__install.html">quickcpplib::_xxx::signal_guard::signal_guard_install</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">On platforms where it is necessary (POSIX), installs, and potentially enables, the global signal handlers for the signals specified by <code>guarded</code>. Each signal installed is threadsafe reference counted, so this is safe to call from multiple threads or instantiate multiple times. It is also guaranteed safe to call from within static data init or deinit, so a very common use case is simply to place an instance into global static data. This ensures that dynamically loaded and unloaded shared objects compose signal guards appropriately.  <a href="classquickcpplib_1_1__xxx_1_1signal__guard_1_1signal__guard__install.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquickcpplib_1_1__xxx_1_1signal__guard_1_1signal__guard__global__decider.html">quickcpplib::_xxx::signal_guard::signal_guard_global_decider&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install a global signal continuation decider.  <a href="classquickcpplib_1_1__xxx_1_1signal__guard_1_1signal__guard__global__decider.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquickcpplib_1_1__xxx_1_1signal__guard_1_1signal__guard__watchdog.html">quickcpplib::_xxx::signal_guard::signal_guard_watchdog&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call an optional specified routine after a period of time, possibly on another thread. Async signal safe.  <a href="classquickcpplib_1_1__xxx_1_1signal__guard_1_1signal__guard__watchdog.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classquickcpplib_1_1__xxx_1_1signal__guard_1_1signal__raised.html">quickcpplib::_xxx::signal_guard::signal_raised</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown by the default signal handler to abort the current operation.  <a href="classquickcpplib_1_1__xxx_1_1signal__guard_1_1signal__raised.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacequickcpplib" id="r_namespacequickcpplib"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickcpplib.html">quickcpplib</a></td></tr>
<tr class="memdesc:namespacequickcpplib"><td class="mdescLeft">&#160;</td><td class="mdescRight">The QuickCppLib namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacequickcpplib_1_1__xxx" id="r_namespacequickcpplib_1_1__xxx"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx.html">quickcpplib::_xxx</a></td></tr>
<tr class="memdesc:namespacequickcpplib_1_1__xxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Per commit unique namespace to prevent different git submodule versions clashing. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacequickcpplib_1_1__xxx_1_1signal__guard" id="r_namespacequickcpplib_1_1__xxx_1_1signal__guard"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html">quickcpplib::_xxx::signal_guard</a></td></tr>
<tr class="memdesc:namespacequickcpplib_1_1__xxx_1_1signal__guard"><td class="mdescLeft">&#160;</td><td class="mdescRight">The namespace for signal_guard. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacequickcpplib_1_1__xxx_1_1signal__guard_1_1detail" id="r_namespacequickcpplib_1_1__xxx_1_1signal__guard_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard_1_1detail.html">quickcpplib::_xxx::signal_guard::detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:afc4c0d35b09e145b05c4a43a7a0aacc2" id="r_afc4c0d35b09e145b05c4a43a7a0aacc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="signal__guard_8hpp.html#afc4c0d35b09e145b05c4a43a7a0aacc2">SIGNALGUARD_CLASS_DECL</a></td></tr>
<tr class="separator:afc4c0d35b09e145b05c4a43a7a0aacc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39634ac32b05085370ca8eae304b76c8" id="r_a39634ac32b05085370ca8eae304b76c8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="signal__guard_8hpp.html#a39634ac32b05085370ca8eae304b76c8">SIGNALGUARD_FUNC_DECL</a>&#160;&#160;&#160;extern</td></tr>
<tr class="separator:a39634ac32b05085370ca8eae304b76c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7cacdb873bcef99c80f51c266192aa" id="r_afb7cacdb873bcef99c80f51c266192aa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="signal__guard_8hpp.html#afb7cacdb873bcef99c80f51c266192aa">SIGNALGUARD_MEMFUNC_DECL</a></td></tr>
<tr class="separator:afb7cacdb873bcef99c80f51c266192aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2a89dc400157b7a86a036c13521ba1c3" id="r_a2a89dc400157b7a86a036c13521ba1c3"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="signal__guard_8hpp.html#a2a89dc400157b7a86a036c13521ba1c3">raised_signal_error_code_t</a></td></tr>
<tr class="memdesc:a2a89dc400157b7a86a036c13521ba1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef to a system specific error code type.  <br /></td></tr>
<tr class="separator:a2a89dc400157b7a86a036c13521ba1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12361db9ccab81c70c9055554e374540" id="r_a12361db9ccab81c70c9055554e374540"><td class="memItemLeft" align="right" valign="top">typedef union <a class="el" href="unionraised__signal__info__value.html">raised_signal_info_value</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="signal__guard_8hpp.html#a12361db9ccab81c70c9055554e374540">thrd_signal_guard_guarded_t</a>) (union <a class="el" href="unionraised__signal__info__value.html">raised_signal_info_value</a>)</td></tr>
<tr class="memdesc:a12361db9ccab81c70c9055554e374540"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the guarded function.  <br /></td></tr>
<tr class="separator:a12361db9ccab81c70c9055554e374540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95601e6c8a95db2668387289c2c6c01c" id="r_a95601e6c8a95db2668387289c2c6c01c"><td class="memItemLeft" align="right" valign="top">typedef union <a class="el" href="unionraised__signal__info__value.html">raised_signal_info_value</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="signal__guard_8hpp.html#a95601e6c8a95db2668387289c2c6c01c">thrd_signal_guard_recover_t</a>) (const struct <a class="el" href="structraised__signal__info.html">raised_signal_info</a> *)</td></tr>
<tr class="memdesc:a95601e6c8a95db2668387289c2c6c01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the function called to recover from a signal being raised in a guarded section.  <br /></td></tr>
<tr class="separator:a95601e6c8a95db2668387289c2c6c01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2d51b67640487fb4858f56e8f9a020" id="r_a5b2d51b67640487fb4858f56e8f9a020"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="signal__guard_8hpp.html#a5b2d51b67640487fb4858f56e8f9a020">thrd_signal_guard_decide_t</a>) (struct <a class="el" href="structraised__signal__info.html">raised_signal_info</a> *)</td></tr>
<tr class="memdesc:a5b2d51b67640487fb4858f56e8f9a020"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the function called when a signal is raised. Returns true to continue guarded code, false to recover.  <br /></td></tr>
<tr class="separator:a5b2d51b67640487fb4858f56e8f9a020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710be9ca5511811977f1a98565ecbf2d" id="r_a710be9ca5511811977f1a98565ecbf2d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a710be9ca5511811977f1a98565ecbf2d">quickcpplib::_xxx::signal_guard::raised_signal_info</a> = <a class="el" href="structraised__signal__info.html">::raised_signal_info</a></td></tr>
<tr class="separator:a710be9ca5511811977f1a98565ecbf2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a31407e66b668f46e52933017eadcf790" id="r_a31407e66b668f46e52933017eadcf790"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790">quickcpplib::_xxx::signal_guard::signalc</a> { <br />
&#160;&#160;<a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790a334c4a4c42fdb79d7ebc3e73b517e6f8">quickcpplib::_xxx::signal_guard::none</a> = 0
, <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790aa22841e8bd002a67221a4ac8858ffc72">quickcpplib::_xxx::signal_guard::abort_process</a> = SIGABRT
, <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790a72f8af2953718eaf9753915ce51fd4af">quickcpplib::_xxx::signal_guard::undefined_memory_access</a> = SIGBUS
, <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790af02b25bbe33547687680941a577b46da">quickcpplib::_xxx::signal_guard::illegal_instruction</a> = SIGILL
, <br />
&#160;&#160;<a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790a2414c252176310b2c04547257948c7b7">quickcpplib::_xxx::signal_guard::interrupt</a>
, <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790a2f0338eed54503152be1d31c93c9c2f1">quickcpplib::_xxx::signal_guard::broken_pipe</a> = SIGPIPE
, <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790a05de49fb26bd786688ca310c6fee826c">quickcpplib::_xxx::signal_guard::segmentation_fault</a> = SIGSEGV
, <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790a66938d975a8e275dc893c7d5f6331fd3">quickcpplib::_xxx::signal_guard::floating_point_error</a> = SIGFPE
, <br />
&#160;&#160;<a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790ab301d33e2bea9550b89d53854f02969e">quickcpplib::_xxx::signal_guard::process_terminate</a>
, <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790a29a37bbcc5d90af766cbadea94d658ed">quickcpplib::_xxx::signal_guard::timer_expire</a> = SIGALRM
, <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790a6e5f4ffd160af47032bf328609b57d8b">quickcpplib::_xxx::signal_guard::child_exit</a> = SIGCHLD
, <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790a4926d1d5f16443cbe8e443a43278ffe1">quickcpplib::_xxx::signal_guard::process_continue</a> = SIGCONT
, <br />
&#160;&#160;<a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790a228065c0f726fc40bc8247370b5ffa3b">quickcpplib::_xxx::signal_guard::tty_hangup</a> = SIGHUP
, <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790a32def8616cfc38bb4c322483ae8395e4">quickcpplib::_xxx::signal_guard::process_kill</a> = SIGKILL
, <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790a3d4ff91b0163960ae7a6968fa3eb5bfb">quickcpplib::_xxx::signal_guard::profile_event</a> = SIGPROF
, <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790a1f4f91447574eee1c2bf2b2d7d6a35fc">quickcpplib::_xxx::signal_guard::process_quit</a> = SIGQUIT
, <br />
&#160;&#160;<a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790ac21801e04dd251e7192a6d97ef8f708e">quickcpplib::_xxx::signal_guard::process_stop</a> = SIGSTOP
, <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790ad32c122e885f71cde4c4740619867313">quickcpplib::_xxx::signal_guard::tty_stop</a> = SIGTSTP
, <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790a537ba7ad3425bb63d64dd1e9f3563e86">quickcpplib::_xxx::signal_guard::bad_system_call</a> = SIGSYS
, <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790aacdb950c0eadaa7d85e9732b26214e6f">quickcpplib::_xxx::signal_guard::process_trap</a> = SIGTRAP
, <br />
&#160;&#160;<a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790a57835b3ff9c01a587c6bf642b6b29137">quickcpplib::_xxx::signal_guard::tty_input</a> = SIGTTIN
, <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790a0c001c9924affddb7c5aecd3d19e1be4">quickcpplib::_xxx::signal_guard::tty_output</a> = SIGTTOU
, <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790a33d679fe9780c3a6223e443d44e6c509">quickcpplib::_xxx::signal_guard::urgent_condition</a> = SIGURG
, <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790ac5eb8e877c4f56bfdb368e1f29681a83">quickcpplib::_xxx::signal_guard::user_defined1</a> = SIGUSR1
, <br />
&#160;&#160;<a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790ac64807acaa55cc93063d98bd38289465">quickcpplib::_xxx::signal_guard::user_defined2</a> = SIGUSR2
, <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790ad732d8696d88d785de5c006adeae958d">quickcpplib::_xxx::signal_guard::virtual_alarm_clock</a> = SIGVTALRM
, <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790aa786c3f062f19d91562c573e0b6cbdc5">quickcpplib::_xxx::signal_guard::cpu_time_limit_exceeded</a> = SIGXCPU
, <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790a8efa0b2d7e2316e4cbb86360909f6b18">quickcpplib::_xxx::signal_guard::file_size_limit_exceeded</a> = SIGXFSZ
, <br />
&#160;&#160;<a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790a3cb0e80c0bd052b9140f2431fa9fd169">quickcpplib::_xxx::signal_guard::cxx_out_of_memory</a> = 32
, <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790a52f93f521a00e90404d357c9762a3c92">quickcpplib::_xxx::signal_guard::cxx_termination</a> = 33
, <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790ad0b5c8fee5fb403009d3876a5c917888">quickcpplib::_xxx::signal_guard::_max_value</a>
<br />
 }</td></tr>
<tr class="memdesc:a31407e66b668f46e52933017eadcf790"><td class="mdescLeft">&#160;</td><td class="mdescRight">The signals which are supported.  <a href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790">More...</a><br /></td></tr>
<tr class="separator:a31407e66b668f46e52933017eadcf790"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a513feb96b55c52300a9d6ed72d298580" id="r_a513feb96b55c52300a9d6ed72d298580"><td class="memItemLeft" align="right" valign="top"><a class="el" href="signal__guard_8hpp.html#a39634ac32b05085370ca8eae304b76c8">SIGNALGUARD_FUNC_DECL</a> union <a class="el" href="unionraised__signal__info__value.html">raised_signal_info_value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="signal__guard_8hpp.html#a513feb96b55c52300a9d6ed72d298580">thrd_signal_guard_call</a> (const sigset_t *signals, <a class="el" href="signal__guard_8hpp.html#a12361db9ccab81c70c9055554e374540">thrd_signal_guard_guarded_t</a> guarded, <a class="el" href="signal__guard_8hpp.html#a95601e6c8a95db2668387289c2c6c01c">thrd_signal_guard_recover_t</a> recovery, <a class="el" href="signal__guard_8hpp.html#a5b2d51b67640487fb4858f56e8f9a020">thrd_signal_guard_decide_t</a> decider, union <a class="el" href="unionraised__signal__info__value.html">raised_signal_info_value</a> value)</td></tr>
<tr class="memdesc:a513feb96b55c52300a9d6ed72d298580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs a thread-local signal guard for the calling thread, and calls the guarded function <code>guarded</code>.  <br /></td></tr>
<tr class="separator:a513feb96b55c52300a9d6ed72d298580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c0b588e32fae9509fb187c85fcc3bb" id="r_a07c0b588e32fae9509fb187c85fcc3bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="signal__guard_8hpp.html#a39634ac32b05085370ca8eae304b76c8">SIGNALGUARD_FUNC_DECL</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="signal__guard_8hpp.html#a07c0b588e32fae9509fb187c85fcc3bb">thrd_raise_signal</a> (int signo, void *raw_info, void *raw_context)</td></tr>
<tr class="memdesc:a07c0b588e32fae9509fb187c85fcc3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the currently installed signal handler for a signal (POSIX), or raise a Win32 structured exception (Windows), returning false if no handler was called due to the currently installed handler being <code>SIG_IGN</code> (POSIX).  <br /></td></tr>
<tr class="separator:a07c0b588e32fae9509fb187c85fcc3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bf6c43ee8d7839e040967455fcc2e3" id="r_a55bf6c43ee8d7839e040967455fcc2e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="signal__guard_8hpp.html#a39634ac32b05085370ca8eae304b76c8">SIGNALGUARD_FUNC_DECL</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="signal__guard_8hpp.html#a55bf6c43ee8d7839e040967455fcc2e3">signal_guard_create</a> (const sigset_t *guarded)</td></tr>
<tr class="memdesc:a55bf6c43ee8d7839e040967455fcc2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">On platforms where it is necessary (POSIX), installs, and potentially enables, the global signal handlers for the signals specified by <code>guarded</code>. Each signal installed is threadsafe reference counted, so this is safe to call from multiple threads or instantiate multiple times.  <br /></td></tr>
<tr class="separator:a55bf6c43ee8d7839e040967455fcc2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afd0771b355d4acd29f1ff3ec1817d4" id="r_a3afd0771b355d4acd29f1ff3ec1817d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="signal__guard_8hpp.html#a39634ac32b05085370ca8eae304b76c8">SIGNALGUARD_FUNC_DECL</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="signal__guard_8hpp.html#a3afd0771b355d4acd29f1ff3ec1817d4">signal_guard_destroy</a> (void *i)</td></tr>
<tr class="memdesc:a3afd0771b355d4acd29f1ff3ec1817d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uninstall a previously installed signal guard.  <br /></td></tr>
<tr class="separator:a3afd0771b355d4acd29f1ff3ec1817d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462ed51c7c9a707e6760a56d59281dc8" id="r_a462ed51c7c9a707e6760a56d59281dc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="signal__guard_8hpp.html#a39634ac32b05085370ca8eae304b76c8">SIGNALGUARD_FUNC_DECL</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="signal__guard_8hpp.html#a462ed51c7c9a707e6760a56d59281dc8">signal_guard_decider_create</a> (const sigset_t *guarded, bool callfirst, <a class="el" href="signal__guard_8hpp.html#a5b2d51b67640487fb4858f56e8f9a020">thrd_signal_guard_decide_t</a> decider, union <a class="el" href="unionraised__signal__info__value.html">raised_signal_info_value</a> value)</td></tr>
<tr class="memdesc:a462ed51c7c9a707e6760a56d59281dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a global signal continuation decider. Threadsafe with respect to other calls of this function, but not reentrant i.e. modifying the global signal continuation decider registry whilst inside a global signal continuation decider is racy. Called after all thread local handling is exhausted. Note that what you can safely do in the decider function is extremely limited, only async signal safe functions may be called.  <br /></td></tr>
<tr class="separator:a462ed51c7c9a707e6760a56d59281dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa7645a3baffab74235e7edb6cbc24d" id="r_a9fa7645a3baffab74235e7edb6cbc24d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="signal__guard_8hpp.html#a39634ac32b05085370ca8eae304b76c8">SIGNALGUARD_FUNC_DECL</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="signal__guard_8hpp.html#a9fa7645a3baffab74235e7edb6cbc24d">signal_guard_decider_destroy</a> (void *decider)</td></tr>
<tr class="memdesc:a9fa7645a3baffab74235e7edb6cbc24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a global signal continuation decider. Threadsafe with respect to other calls of this function, but not reentrant i.e. do not call whilst inside a global signal continuation decider.  <br /></td></tr>
<tr class="separator:a9fa7645a3baffab74235e7edb6cbc24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24aefe1560e2bc5d78180c90e8b27a52" id="r_a24aefe1560e2bc5d78180c90e8b27a52"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a24aefe1560e2bc5d78180c90e8b27a52">quickcpplib::_xxx::signal_guard::QUICKCPPLIB_BITFIELD_BEGIN_T</a> (signalc_set, uint64_t)</td></tr>
<tr class="memdesc:a24aefe1560e2bc5d78180c90e8b27a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitfield for the signals which are supported.  <br /></td></tr>
<tr class="separator:a24aefe1560e2bc5d78180c90e8b27a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc0b10c3ca065c8e2d8a33b3a16aafe" id="r_a2cc0b10c3ca065c8e2d8a33b3a16aafe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="signal__guard_8hpp.html#a39634ac32b05085370ca8eae304b76c8">SIGNALGUARD_FUNC_DECL</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard_1_1detail.html#a2cc0b10c3ca065c8e2d8a33b3a16aafe">quickcpplib::_xxx::signal_guard::detail::signalc_to_string</a> (<a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790">signalc</a> code) noexcept</td></tr>
<tr class="separator:a2cc0b10c3ca065c8e2d8a33b3a16aafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855b452cbf3675bc4cc27ac2f9f6d880" id="r_a855b452cbf3675bc4cc27ac2f9f6d880"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; signalc_set &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard_1_1detail.html#a855b452cbf3675bc4cc27ac2f9f6d880">quickcpplib::_xxx::signal_guard::detail::signal_guards_installed</a> ()</td></tr>
<tr class="separator:a855b452cbf3675bc4cc27ac2f9f6d880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac347effeaf1bf37002390e8bcb27be83" id="r_ac347effeaf1bf37002390e8bcb27be83"><td class="memTemplParams" colspan="2">template&lt;class U , typename  = decltype( std::declval&lt;U&gt;()((raised_signal_info *) 0) )&gt; </td></tr>
<tr class="memitem:ac347effeaf1bf37002390e8bcb27be83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classquickcpplib_1_1__xxx_1_1signal__guard_1_1signal__guard__global__decider.html">signal_guard_global_decider</a>&lt; std::decay_t&lt; U &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#ac347effeaf1bf37002390e8bcb27be83">quickcpplib::_xxx::signal_guard::make_signal_guard_global_decider</a> (signalc_set guarded, U &amp;&amp;f, bool callfirst=false)</td></tr>
<tr class="memdesc:ac347effeaf1bf37002390e8bcb27be83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience instantiator of <code>signal_guard_global_decider</code>.  <br /></td></tr>
<tr class="separator:ac347effeaf1bf37002390e8bcb27be83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b20dfa20a5b0d0eefb2a0760baff8b" id="r_ae4b20dfa20a5b0d0eefb2a0760baff8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="signal__guard_8hpp.html#a39634ac32b05085370ca8eae304b76c8">SIGNALGUARD_FUNC_DECL</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#ae4b20dfa20a5b0d0eefb2a0760baff8b">quickcpplib::_xxx::signal_guard::thrd_raise_signal</a> (<a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a31407e66b668f46e52933017eadcf790">signalc</a> signo, void *raw_info=nullptr, void *raw_context=nullptr)</td></tr>
<tr class="memdesc:ae4b20dfa20a5b0d0eefb2a0760baff8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the currently installed signal handler for a signal (POSIX), or raise a Win32 structured exception (Windows), returning false if no handler was called due to the currently installed handler being <code>SIG_IGN</code> (POSIX).  <br /></td></tr>
<tr class="separator:ae4b20dfa20a5b0d0eefb2a0760baff8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd98d6c6ea207d05458905cb4fefd34d" id="r_acd98d6c6ea207d05458905cb4fefd34d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#a12fd80b884ef35d73f050ea3a42e519d">QUICKCPPLIB_NORETURN</a> <a class="el" href="signal__guard_8hpp.html#a39634ac32b05085370ca8eae304b76c8">SIGNALGUARD_FUNC_DECL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#acd98d6c6ea207d05458905cb4fefd34d">quickcpplib::_xxx::signal_guard::terminate_process_immediately</a> (const char *msg=nullptr) noexcept</td></tr>
<tr class="memdesc:acd98d6c6ea207d05458905cb4fefd34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This initiates a fast fail process termination which immediately exits the process without calling any handlers: on POSIX, this is <code>SIGKILL</code>, on Windows this is <code>TerminateProcess()</code>.  <br /></td></tr>
<tr class="separator:acd98d6c6ea207d05458905cb4fefd34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac956ec23b29700e9bb38826556dfbb5d" id="r_ac956ec23b29700e9bb38826556dfbb5d"><td class="memTemplParams" colspan="2">template&lt;class U , typename  = decltype( std::declval&lt;U&gt;()() )&gt; </td></tr>
<tr class="memitem:ac956ec23b29700e9bb38826556dfbb5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classquickcpplib_1_1__xxx_1_1signal__guard_1_1signal__guard__watchdog.html">signal_guard_watchdog</a>&lt; std::decay_t&lt; U &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#ac956ec23b29700e9bb38826556dfbb5d">quickcpplib::_xxx::signal_guard::make_signal_guard_watchdog</a> (U &amp;&amp;f, unsigned ms=3000)</td></tr>
<tr class="memdesc:ac956ec23b29700e9bb38826556dfbb5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience instantiator of <code>signal_guard_watchdog</code>.  <br /></td></tr>
<tr class="separator:ac956ec23b29700e9bb38826556dfbb5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3224985eb10d89da9dcee34e8a4d16" id="r_afa3224985eb10d89da9dcee34e8a4d16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classquickcpplib_1_1__xxx_1_1signal__guard_1_1signal__guard__watchdog.html">signal_guard_watchdog</a>&lt; detail::invoke_terminate_process_immediately &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#afa3224985eb10d89da9dcee34e8a4d16">quickcpplib::_xxx::signal_guard::make_signal_guard_watchdog</a> (unsigned ms=3000)</td></tr>
<tr class="memdesc:afa3224985eb10d89da9dcee34e8a4d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience instantiator of <code>signal_guard_watchdog</code>.  <br /></td></tr>
<tr class="separator:afa3224985eb10d89da9dcee34e8a4d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c110b41f86708c4ef656bb42888afc" id="r_a68c110b41f86708c4ef656bb42888afc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="signal__guard_8hpp.html#a39634ac32b05085370ca8eae304b76c8">SIGNALGUARD_FUNC_DECL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard_1_1detail.html#a68c110b41f86708c4ef656bb42888afc">quickcpplib::_xxx::signal_guard::detail::push_thread_local_signal_handler</a> (thread_local_signal_guard *) noexcept</td></tr>
<tr class="separator:a68c110b41f86708c4ef656bb42888afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79b558dcc456cc3b4f551e575b58ffb" id="r_ae79b558dcc456cc3b4f551e575b58ffb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="signal__guard_8hpp.html#a39634ac32b05085370ca8eae304b76c8">SIGNALGUARD_FUNC_DECL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard_1_1detail.html#ae79b558dcc456cc3b4f551e575b58ffb">quickcpplib::_xxx::signal_guard::detail::pop_thread_local_signal_handler</a> (thread_local_signal_guard *) noexcept</td></tr>
<tr class="separator:ae79b558dcc456cc3b4f551e575b58ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7db48fdb2364ceff2a9da4395b2be66" id="r_aa7db48fdb2364ceff2a9da4395b2be66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="signal__guard_8hpp.html#a39634ac32b05085370ca8eae304b76c8">SIGNALGUARD_FUNC_DECL</a> thread_local_signal_guard *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard_1_1detail.html#aa7db48fdb2364ceff2a9da4395b2be66">quickcpplib::_xxx::signal_guard::detail::current_thread_local_signal_handler</a> () noexcept</td></tr>
<tr class="separator:aa7db48fdb2364ceff2a9da4395b2be66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88307c108cb9a38f92fc4f1ef6e467d4" id="r_a88307c108cb9a38f92fc4f1ef6e467d4"><td class="memTemplParams" colspan="2">template&lt;class R &gt; </td></tr>
<tr class="memitem:a88307c108cb9a38f92fc4f1ef6e467d4"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard_1_1detail.html#a88307c108cb9a38f92fc4f1ef6e467d4">quickcpplib::_xxx::signal_guard::detail::throw_signal_raised</a> (const <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a710be9ca5511811977f1a98565ecbf2d">raised_signal_info</a> *i)</td></tr>
<tr class="separator:a88307c108cb9a38f92fc4f1ef6e467d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c66ccd24d574d61cfb576263f5f320" id="r_ac2c66ccd24d574d61cfb576263f5f320"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard_1_1detail.html#ac2c66ccd24d574d61cfb576263f5f320">quickcpplib::_xxx::signal_guard::detail::continue_or_handle</a> (const <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a710be9ca5511811977f1a98565ecbf2d">raised_signal_info</a> *) noexcept</td></tr>
<tr class="separator:ac2c66ccd24d574d61cfb576263f5f320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e58816107576cbfe0c84b0a477620c" id="r_a81e58816107576cbfe0c84b0a477620c"><td class="memTemplParams" colspan="2">template&lt;class F , class H , class C , class... Args, class R  = decltype(std::declval&lt;F&gt;()(std::declval&lt;Args&gt;()...)), typename std::enable_if&lt;(detail::is_constructible_or_void&lt; R, decltype(std::declval&lt; H &gt;()(std::declval&lt; const <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a710be9ca5511811977f1a98565ecbf2d">raised_signal_info</a> * &gt;()))&gt;::value), bool &gt;::type  = true, typename std::enable_if&lt;(detail::is_constructible_or_void&lt; bool, decltype(std::declval&lt; C &gt;()(std::declval&lt; <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a710be9ca5511811977f1a98565ecbf2d">raised_signal_info</a> * &gt;()))&gt;::value), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:a81e58816107576cbfe0c84b0a477620c"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a81e58816107576cbfe0c84b0a477620c">quickcpplib::_xxx::signal_guard::signal_guard</a> (signalc_set guarded, F &amp;&amp;f, H &amp;&amp;h, C &amp;&amp;c, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a81e58816107576cbfe0c84b0a477620c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cbc88f5bc098a33d1f6fb544f99d44" id="r_a06cbc88f5bc098a33d1f6fb544f99d44"><td class="memTemplParams" colspan="2">template&lt;class F , class R  = decltype(std::declval&lt;F&gt;()())&gt; </td></tr>
<tr class="memitem:a06cbc88f5bc098a33d1f6fb544f99d44"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a06cbc88f5bc098a33d1f6fb544f99d44">quickcpplib::_xxx::signal_guard::signal_guard</a> (signalc_set guarded, F &amp;&amp;f)</td></tr>
<tr class="memdesc:a06cbc88f5bc098a33d1f6fb544f99d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a06cbc88f5bc098a33d1f6fb544f99d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe0cfd544ac327234681d4ae7b706f5" id="r_aefe0cfd544ac327234681d4ae7b706f5"><td class="memTemplParams" colspan="2">template&lt;class F , class H , class R  = decltype(std::declval&lt;F&gt;()()), typename std::enable_if&lt;(detail::is_constructible_or_void&lt; R, decltype(std::declval&lt; H &gt;()(std::declval&lt; const <a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#a710be9ca5511811977f1a98565ecbf2d">raised_signal_info</a> * &gt;()))&gt;::value), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:aefe0cfd544ac327234681d4ae7b706f5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacequickcpplib_1_1__xxx_1_1signal__guard.html#aefe0cfd544ac327234681d4ae7b706f5">quickcpplib::_xxx::signal_guard::signal_guard</a> (signalc_set guarded, F &amp;&amp;f, H &amp;&amp;h)</td></tr>
<tr class="memdesc:aefe0cfd544ac327234681d4ae7b706f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aefe0cfd544ac327234681d4ae7b706f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="afc4c0d35b09e145b05c4a43a7a0aacc2" name="afc4c0d35b09e145b05c4a43a7a0aacc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4c0d35b09e145b05c4a43a7a0aacc2">&#9670;&#160;</a></span>SIGNALGUARD_CLASS_DECL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIGNALGUARD_CLASS_DECL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a39634ac32b05085370ca8eae304b76c8" name="a39634ac32b05085370ca8eae304b76c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39634ac32b05085370ca8eae304b76c8">&#9670;&#160;</a></span>SIGNALGUARD_FUNC_DECL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIGNALGUARD_FUNC_DECL&#160;&#160;&#160;extern</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb7cacdb873bcef99c80f51c266192aa" name="afb7cacdb873bcef99c80f51c266192aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7cacdb873bcef99c80f51c266192aa">&#9670;&#160;</a></span>SIGNALGUARD_MEMFUNC_DECL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIGNALGUARD_MEMFUNC_DECL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a2a89dc400157b7a86a036c13521ba1c3" name="a2a89dc400157b7a86a036c13521ba1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a89dc400157b7a86a036c13521ba1c3">&#9670;&#160;</a></span>raised_signal_error_code_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="signal__guard_8hpp.html#a2a89dc400157b7a86a036c13521ba1c3">raised_signal_error_code_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef to a system specific error code type. </p>

</div>
</div>
<a id="a12361db9ccab81c70c9055554e374540" name="a12361db9ccab81c70c9055554e374540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12361db9ccab81c70c9055554e374540">&#9670;&#160;</a></span>thrd_signal_guard_guarded_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union <a class="el" href="unionraised__signal__info__value.html">raised_signal_info_value</a>(* thrd_signal_guard_guarded_t) (union <a class="el" href="unionraised__signal__info__value.html">raised_signal_info_value</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the guarded function. </p>

</div>
</div>
<a id="a95601e6c8a95db2668387289c2c6c01c" name="a95601e6c8a95db2668387289c2c6c01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95601e6c8a95db2668387289c2c6c01c">&#9670;&#160;</a></span>thrd_signal_guard_recover_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union <a class="el" href="unionraised__signal__info__value.html">raised_signal_info_value</a>(* thrd_signal_guard_recover_t) (const struct <a class="el" href="structraised__signal__info.html">raised_signal_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the function called to recover from a signal being raised in a guarded section. </p>

</div>
</div>
<a id="a5b2d51b67640487fb4858f56e8f9a020" name="a5b2d51b67640487fb4858f56e8f9a020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2d51b67640487fb4858f56e8f9a020">&#9670;&#160;</a></span>thrd_signal_guard_decide_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* thrd_signal_guard_decide_t) (struct <a class="el" href="structraised__signal__info.html">raised_signal_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the function called when a signal is raised. Returns true to continue guarded code, false to recover. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a513feb96b55c52300a9d6ed72d298580" name="a513feb96b55c52300a9d6ed72d298580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513feb96b55c52300a9d6ed72d298580">&#9670;&#160;</a></span>thrd_signal_guard_call()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="signal__guard_8hpp.html#a39634ac32b05085370ca8eae304b76c8">SIGNALGUARD_FUNC_DECL</a> union <a class="el" href="unionraised__signal__info__value.html">raised_signal_info_value</a> thrd_signal_guard_call </td>
          <td>(</td>
          <td class="paramtype">const sigset_t *&#160;</td>
          <td class="paramname"><em>signals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="signal__guard_8hpp.html#a12361db9ccab81c70c9055554e374540">thrd_signal_guard_guarded_t</a>&#160;</td>
          <td class="paramname"><em>guarded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="signal__guard_8hpp.html#a95601e6c8a95db2668387289c2c6c01c">thrd_signal_guard_recover_t</a>&#160;</td>
          <td class="paramname"><em>recovery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="signal__guard_8hpp.html#a5b2d51b67640487fb4858f56e8f9a020">thrd_signal_guard_decide_t</a>&#160;</td>
          <td class="paramname"><em>decider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="unionraised__signal__info__value.html">raised_signal_info_value</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs a thread-local signal guard for the calling thread, and calls the guarded function <code>guarded</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The value returned by <code>guarded</code>, or <code>recovery</code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signals</td><td>The set of signals to guard against. </td></tr>
    <tr><td class="paramname">guarded</td><td>A function whose execution is to be guarded against signal raises. </td></tr>
    <tr><td class="paramname">recovery</td><td>A function to be called if a signal is raised. </td></tr>
    <tr><td class="paramname">decider</td><td>A function to be called to decide whether to recover from the signal and continue the execution of the guarded routine, or to abort and call the recovery routine. </td></tr>
    <tr><td class="paramname">value</td><td>A value to supply to the guarded routine. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07c0b588e32fae9509fb187c85fcc3bb" name="a07c0b588e32fae9509fb187c85fcc3bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c0b588e32fae9509fb187c85fcc3bb">&#9670;&#160;</a></span>thrd_raise_signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="signal__guard_8hpp.html#a39634ac32b05085370ca8eae304b76c8">SIGNALGUARD_FUNC_DECL</a> bool thrd_raise_signal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>raw_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>raw_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the currently installed signal handler for a signal (POSIX), or raise a Win32 structured exception (Windows), returning false if no handler was called due to the currently installed handler being <code>SIG_IGN</code> (POSIX). </p>
<p>Note that on POSIX, we fetch the currently installed signal handler and try to call it directly. This allows us to supply custom <code>raw_info</code> and <code>raw_context</code>, and we do all the things which the signal handler flags tell us to do beforehand [1]. If the current handler has been defaulted, we enable the signal and execute <code>pthread_kill(pthread_self(), signo)</code> in order to invoke the default handling.</p>
<p>Note that on Windows, <code>raw_context</code> is ignored as there is no way to override the context thrown with a Win32 structured exception.</p>
<p>[1]: We currently do not implement alternative stack switching. If a handler requests that, we simply abort the process. Code donations implementing support are welcome. </p>

</div>
</div>
<a id="a55bf6c43ee8d7839e040967455fcc2e3" name="a55bf6c43ee8d7839e040967455fcc2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55bf6c43ee8d7839e040967455fcc2e3">&#9670;&#160;</a></span>signal_guard_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="signal__guard_8hpp.html#a39634ac32b05085370ca8eae304b76c8">SIGNALGUARD_FUNC_DECL</a> void * signal_guard_create </td>
          <td>(</td>
          <td class="paramtype">const sigset_t *&#160;</td>
          <td class="paramname"><em>guarded</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>On platforms where it is necessary (POSIX), installs, and potentially enables, the global signal handlers for the signals specified by <code>guarded</code>. Each signal installed is threadsafe reference counted, so this is safe to call from multiple threads or instantiate multiple times. </p>
<p>On platforms with better than POSIX global signal support, this function does nothing.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
POSIX only</h2>
<p>Any existing global signal handlers are replaced with a filtering signal handler, which checks if the current kernel thread has installed a signal guard, and if so executes the guard. If no signal guard has been installed for the current kernel thread, global signal continuation handlers are executed. If none claims the signal, the previously installed signal handler is called.</p>
<p>After the new signal handlers have been installed, the guarded signals are globally enabled for all threads of execution. Be aware that the handlers are installed with <code>SA_NODEFER</code> to avoid the need to perform an expensive syscall when a signal is handled. However this may also produce surprise e.g. infinite loops.</p>
<dl class="section warning"><dt>Warning</dt><dd>This class is threadsafe with respect to other concurrent executions of itself, but is NOT threadsafe with respect to other code modifying the global signal handlers. </dd></dl>

</div>
</div>
<a id="a3afd0771b355d4acd29f1ff3ec1817d4" name="a3afd0771b355d4acd29f1ff3ec1817d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3afd0771b355d4acd29f1ff3ec1817d4">&#9670;&#160;</a></span>signal_guard_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="signal__guard_8hpp.html#a39634ac32b05085370ca8eae304b76c8">SIGNALGUARD_FUNC_DECL</a> bool signal_guard_destroy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uninstall a previously installed signal guard. </p>

</div>
</div>
<a id="a462ed51c7c9a707e6760a56d59281dc8" name="a462ed51c7c9a707e6760a56d59281dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462ed51c7c9a707e6760a56d59281dc8">&#9670;&#160;</a></span>signal_guard_decider_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="signal__guard_8hpp.html#a39634ac32b05085370ca8eae304b76c8">SIGNALGUARD_FUNC_DECL</a> void * signal_guard_decider_create </td>
          <td>(</td>
          <td class="paramtype">const sigset_t *&#160;</td>
          <td class="paramname"><em>guarded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>callfirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="signal__guard_8hpp.html#a5b2d51b67640487fb4858f56e8f9a020">thrd_signal_guard_decide_t</a>&#160;</td>
          <td class="paramname"><em>decider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="unionraised__signal__info__value.html">raised_signal_info_value</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a global signal continuation decider. Threadsafe with respect to other calls of this function, but not reentrant i.e. modifying the global signal continuation decider registry whilst inside a global signal continuation decider is racy. Called after all thread local handling is exhausted. Note that what you can safely do in the decider function is extremely limited, only async signal safe functions may be called. </p>
<dl class="section return"><dt>Returns</dt><dd>An opaque pointer to the registered decider. <code>NULL</code> if <code>malloc</code> failed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">guarded</td><td>The set of signals to be guarded against. </td></tr>
    <tr><td class="paramname">callfirst</td><td>True if this decider should be called before any other. Otherwise call order is in the order of addition. </td></tr>
    <tr><td class="paramname">decider</td><td>A decider function, which must return <code>true</code> if execution is to resume, <code>false</code> if the next decider function should be called. </td></tr>
    <tr><td class="paramname">value</td><td>A user supplied value to set in the <code>raised_signal_info</code> passed to the decider callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fa7645a3baffab74235e7edb6cbc24d" name="a9fa7645a3baffab74235e7edb6cbc24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa7645a3baffab74235e7edb6cbc24d">&#9670;&#160;</a></span>signal_guard_decider_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="signal__guard_8hpp.html#a39634ac32b05085370ca8eae304b76c8">SIGNALGUARD_FUNC_DECL</a> bool signal_guard_decider_destroy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>decider</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a global signal continuation decider. Threadsafe with respect to other calls of this function, but not reentrant i.e. do not call whilst inside a global signal continuation decider. </p>
<dl class="section return"><dt>Returns</dt><dd>True if recognised and thus removed. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_d1498f5694bf8fd9ebfffeb3ee9c2787.html">quickcpplib</a></li><li class="navelem"><a class="el" href="signal__guard_8hpp.html">signal_guard.hpp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
